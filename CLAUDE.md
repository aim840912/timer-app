# 開發指南

> 純前端計時器應用 - Next.js 16 + GitHub Pages

## 📑 目錄

- [🚀 快速開始](#-快速開始)
- [🤖 Claude 行為準則](#-claude-行為準則)
- [📐 開發理念](#-開發理念)
- [🔧 開發流程](#-開發流程)
- [💎 程式碼品質標準](#-程式碼品質標準)
- [🎨 UI/UX 設計規範](#-uiux-設計規範)

---

## 🚀 快速開始

### 5 秒速查

```bash
# 開發前必做
npm run type-check && npm run lint

# 常用指令
npm run dev          # 啟動開發伺服器
npm run build        # 建置靜態網站
npm run type-check   # TypeScript 檢查
npm run lint         # 程式碼品質檢查
```

### 核心原則（3 條）

1. **使用繁體中文** - 所有溝通均使用繁體中文
2. **使用 TodoWrite 追蹤複雜任務** - 完成後立即標記 completed
3. **保持程式碼簡潔** - 避免過早優化，優先考慮可讀性

### 專案特性

- ✅ **純前端應用** - 無後端 API、資料庫、認證系統
- ✅ **靜態匯出** - 部署到 GitHub Pages
- ✅ **技術棧** - Next.js 16 + TypeScript + Tailwind CSS 4
- ✅ **依賴** - Framer Motion（動畫）、Lucide React（圖示）、Howler（音效）

### 常用指令

```bash
# 開發流程
npm run dev                          # 啟動開發伺服器 (Turbopack)
npm run build                        # 建置靜態網站到 out/ 目錄
npm run type-check                   # 檢查 TypeScript 類型
npm run lint                         # 檢查程式碼品質
npm run clean                        # 清理建置快取
npm run export                       # 清理並建置（完整流程）

# 維護檢查
npm audit                            # 安全性檢查
npx depcheck                         # 檢查未使用依賴
```

---

## 🤖 Claude 行為準則

### 執行原則

- **精確執行** - 只做被要求的事，不多不少
- **謹慎建立檔案** - 只在絕對必要時建立新檔案，優先編輯現有檔案
- **不主動建立文檔** - 除非使用者明確要求，否則不建立 *.md 或 README 檔案

### Git 提交流程

- **Commit 前必須詢問**：
  1. 展示變更的檔案列表 (`git status`, `git diff --stat`)
  2. 展示完整的 commit message 草稿
  3. 等待使用者明確確認後才執行 commit
  4. 確認後才可執行 `git add` 和 `git commit`

- **Push 前必須詢問**：
  1. 詢問使用者是否要推送到 remote
  2. 等待使用者明確確認後才執行 `git push`
  3. 永不自動執行 push 操作

### TodoWrite 使用規範

#### 基本原則

將複雜工作分解為 3-5 個階段，使用 TodoWrite 工具追蹤進度：

```typescript
TodoWrite({
  todos: [
    { content: "階段 1: [具體目標]", status: "pending", activeForm: "執行階段 1中" },
    { content: "階段 2: [具體目標]", status: "pending", activeForm: "執行階段 2中" }
  ]
})
```

#### 狀態管理規則

1. **狀態轉換順序**：
   - pending (待處理) → in_progress (進行中) → completed (已完成)
   - 永不跳過 in_progress 直接標記為 completed

2. **一次只有一個 in_progress**：
   - 同一時間只能有一個任務狀態為 `in_progress`
   - 開始新任務前必須先完成當前任務

3. **立即更新原則**：
   - ✅ 開始任務時：**立即**標記為 `in_progress`
   - ✅ 完成任務後：**立即**標記為 `completed`
   - ❌ 不要批量處理多個任務的狀態更新

4. **任務描述格式**：
   - `content`: 命令式（例：「建立計時器元件」）
   - `activeForm`: 現在進行式（例：「建立計時器元件中」）

5. **完成條件要求**：
   - **僅當任務完全完成時**才標記為 `completed`
   - 如果遇到錯誤或阻塞，保持 `in_progress`
   - 永不標記未完成的任務為 `completed`

**何時不標記為 completed**：
- 編譯失敗時
- 實作部分完成時
- 遇到未解決的錯誤時
- 找不到必要檔案或依賴時
- 被阻塞無法繼續時

---

## 📐 開發理念

### 核心信念

- **漸進式進展優於大爆炸式改變** - 小的變更能編譯並通過測試
- **從現有程式碼中學習** - 在實作前先研究和規劃
- **實用主義優於教條主義** - 適應專案現實
- **清晰意圖優於巧妙程式碼** - 保持無趣和明顯
- **單一職責原則** - 每個函數/元件單一職責，避免過早抽象化
- **高信心原則** - 不確定時說「不知道」，優先研究和驗證而非猜測

### 永不 與 始終

**永不**：
- 使用 `--no-verify` 繞過提交鉤子
- 提交不能編譯的程式碼
- 做假設 - 用現有程式碼驗證
- **在沒有理由的情況下安裝依賴** - 始終在提交訊息中解釋原因
- **建立重複功能** - 先用 grep/搜尋檢查現有程式碼
- **忽略效能警告** - 解決套件大小和建置時間問題

**始終**：
- 漸進式提交可工作的程式碼
- 從現有實作中學習
- 3 次嘗試失敗後停止並重新評估
- **監控技術債信號** - 建置時間增加、TypeScript 錯誤、ESLint 警告、重複程式碼

### 決策框架

當存在多種有效方法時，根據以下原則選擇：

1. **可測試性** - 我能輕易測試這個嗎？
2. **可讀性** - 6 個月後有人能理解這個嗎？
3. **一致性** - 這是否符合專案模式？
4. **簡潔性** - 這是否最簡單可行的解決方案？
5. **可逆性** - 後續更改有多困難？

---

## 🔧 開發流程

### 開發前檢查

**每次開發前執行**：
```bash
npm run type-check && npm run lint
```

### 實作流程

1. **理解** - 研究程式碼庫中的現有模式
2. **實作** - 編寫功能程式碼
3. **測試** - 手動測試功能是否正常運作
4. **重構** - 在功能正常的情況下清理
5. **提交** - 使用清晰的訊息解釋「為什麼」

### 遇到困難時（嘗試 3 次後）

**重要**：每個問題最多嘗試 3 次，然後停止。

1. **記錄失敗原因**：
   - 你嘗試了什麼
   - 具體的錯誤訊息
   - 你認為為什麼失敗

2. **研究替代方案**：
   - 找到 2-3 個類似的實作
   - 記錄使用的不同方法

3. **質疑基本原則**：
   - 這是否正確的抽象層級？
   - 能否將其分解為更小的問題？
   - 是否有更簡單的方法？

4. **嘗試不同角度**：
   - 不同的函式庫/框架功能？
   - 不同的架構模式？
   - 移除抽象而不是添加？

---

## 💎 程式碼品質標準

### 架構原則

- **組合優於繼承** - 使用 React Hooks 和組合模式
- **明確優於隱含** - 清晰的資料流和依賴關係
- **單一職責** - 每個元件/函數只做一件事

### 程式碼品質要求

**每次提交必須**：
- 編譯成功（`npm run type-check` 通過）
- 通過 linting（`npm run lint` 通過）
- 遵循專案格式化慣例

**提交前**：
- **先向使用者確認** - 展示變更檔案和 commit message 草稿
- 運行 `npm run type-check && npm run lint`
- 自我審查變更
- 確保提交訊息解釋「為什麼」

### 品質標準（建議）

- 相同邏輯出現 **3+ 次** → 考慮抽取為共用函數/元件
- 元件建議 **< 200 行** / 函數建議 **< 30 行** / Props 建議 **< 7 個**
- 巢狀層數建議 **< 3 層** / 參數數量建議 **< 5 個**
- 使用 custom hooks 封裝複雜邏輯

### 技術債信號

- 🔴 建置時間增加 > 30 秒
- 🔴 TypeScript/ESLint 錯誤或警告數量增加
- 🔴 相似功能在多處重複實作
- 🔴 依賴套件版本過舊或有安全漏洞

**遇到技術債信號時**：
1. **記錄問題** - 使用 TODO 註釋
2. **考慮重構** - 而不是增加問題
3. **參考現有實作** - 尋找類似的模式

### 依賴管理

**新增依賴前必須檢查**:

```bash
# 1. 檢查是否已有相似功能
npm ls | grep similar-functionality

# 2. 評估套件健康度
npm info package-name
npm audit

# 3. 檢查未使用依賴
npx depcheck
```

**依賴管理規則**:
- **避免** 安裝功能重複的套件
- **謹慎** 安裝超過 1 年未更新的套件（除非是穩定庫）
- **評估** 增加 bundle > 100KB 的套件影響
- **必須** 在 commit message 說明為什麼需要新依賴

### React/Next.js 最佳實踐

- 使用 TypeScript 定義所有 Props 和 State
- 使用 `use client` directive 標記客戶端元件
- 避免在元件內直接操作 DOM（使用 refs）
- 使用 Tailwind CSS 而非內聯樣式
- 使用 `next/image` 優化圖片（已設定 `unoptimized: true`）

---

## 🎨 UI/UX 設計規範

### 視覺設計原則

1. **禁止使用漸層**
   - ❌ `bg-gradient-to-r from-blue-500 to-purple-600`
   - ✅ `bg-blue-500`
   - 理由：保持視覺簡潔、提升效能、易於維護

2. **禁止使用 Emoji**
   - ❌ `🎯` `✅` `❌` `📊` `🔍`
   - ✅ 使用 SVG 圖示替代（Lucide React）
   - 理由：emoji 在不同平台顯示不一致、無法精確控制樣式、影響無障礙體驗

3. **使用 SVG 圖示**
   - 使用 Lucide React 圖示庫
   - 確保 SVG 支援深色模式（使用 `currentColor`）
   - 提供適當的 `aria-label` 以支援無障礙
   - SVG 應具有適當的尺寸類別（如 `w-6 h-6`）

**範例**：

```tsx
import { Check, X } from 'lucide-react'

// ❌ 錯誤：使用 emoji
<div>{isSuccess ? '✅' : '❌'} 操作結果</div>

// ✅ 正確：使用 Lucide React 圖示
<div className="flex items-center gap-2">
  {isSuccess ? (
    <Check className="w-5 h-5 text-green-600" aria-label="成功" />
  ) : (
    <X className="w-5 h-5 text-red-600" aria-label="失敗" />
  )}
  <span>操作結果</span>
</div>
```

### 無障礙性（Accessibility）

- 為所有互動元素提供適當的 `aria-label`
- 確保顏色對比度符合 WCAG 標準
- 支援鍵盤導航
- 使用語義化 HTML 標籤

---

## ✅ 完成定義

- [ ] 程式碼編譯成功
- [ ] 程式碼遵循專案慣例
- [ ] 沒有 TypeScript/ESLint 警告
- [ ] 提交訊息清晰
- [ ] 實作符合計劃
- [ ] 功能在瀏覽器中正常運作
